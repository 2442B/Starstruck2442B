#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port2,           driveLeftFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           driveRightFront, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           driveLeftBack, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           driveRightBack, tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma systemFile

int target = 0;
int motorPower = 0;

void setLeftDrivePower(int power)
{
	motor[driveLeftBack] = power;
	motor[driveLeftFront] = power;
}
void setRightDrivePower(int power)
{
	motor[driveRightBack] = power;
	motor[driveRightFront] = power;
}
void driveForTime(int time, int power)
{
	setLeftDrivePower(power);
	setRightDrivePower(power);
	wait1Msec(time);

	setLeftDrivePower(0);
	setRightDrivePower(0);
}
void driveForDistance(int numClicks, int power = 127)
{
	target = numClicks;
	motorPower = power;
}
void driveBackForDistance(int numClicks, int power, int stopPower = 6)
{
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	int leftEn = 0;
	int rightEn = 0;
	int bufferZone = 15;

	while(leftEn < abs(numClicks) || rightEn < abs(numClicks))
	{
		leftEn = abs(SensorValue[leftEncoder]);
		rightEn = abs(SensorValue[rightEncoder]);
		setLeftDrivePower(power);
		setRightDrivePower(power);

		int bufferZone = 50;
		if(leftEn >= rightEn + bufferZone) //left side far ahead
		{
			if(power + 45 >= 0)
				setLeftDrivePower(0);
			else
				setLeftDrivePower(power + 45); //may need to be changed
		}
		else if(rightEn >= leftEn + bufferZone)
		{
			if(power + 45 >= 0)
				setRightDrivePower(0);
			else
				setRightDrivePower(power + 45); //may need to be changed
		}

		if(rightEn >= abs(numClicks))
			setRightDrivePower(0);
		else if(leftEn >= abs(numClicks))
			setLeftDrivePower(0);
	}
	driveForTime(100,stopPower); //prevents glide

	setLeftDrivePower(0);
	setRightDrivePower(0);
}

void turnClockwise(int angle)
{
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;

	float convAngle = (angle * 232) / 90;
	int leftEn = 0;
	int rightEn = 0;

	while(leftEn < convAngle || rightEn < convAngle)
	{
		leftEn = SensorValue(leftEncoder);
		rightEn = SensorValue(rightEncoder);

		setLeftDrivePower(127);
		setRightDrivePower(-127);

		if(leftEn >= convAngle)
			setLeftDrivePower(0);
		if(rightEn <= -convAngle)
			setRightDrivePower(0);
	}
	setLeftDrivePower(-10);
	setRightDrivePower(10);
}

void turnCounterClockwise(int angle)
{
	SensorValue(leftEncoder) = 0;
	SensorValue(rightEncoder) = 0;

	int leftEn = 0;
	int rightEn = 0;

	float convAngle = (angle * 190) / 90;

	while(leftEn > -convAngle || rightEn > -convAngle)
	{
		leftEn = SensorValue(leftEncoder); //going to negative
		rightEn = SensorValue(rightEncoder); //going to negative as well

		setLeftDrivePower(-127);
		setRightDrivePower(127);

		if(leftEn <= -convAngle)
			setLeftDrivePower(0);
		if(rightEn <= -convAngle)
			setRightDrivePower(0);
	}
	setLeftDrivePower(10);
	setRightDrivePower(-10);
}

task usercontrol()
{
	bool pinpointDrive = false;
	while(true)
	{
		int setPoint = 3000;

		//Buttons and Joysticks
		int  rightJoy = vexRT[Ch2];
		int  leftJoy = vexRT[Ch3];
		word rightTriggerUp = vexRT[Btn6U]; //for up lift
		word rightTriggerDown = vexRT[Btn6D]; //for down lift
		word leftTriggerUp = vexRT[Btn5U]; //for pincer close
		word leftTriggerDown = vexRT[Btn5D]; //for pincer open
		word btnEightDown = vexRT[Btn8D]; //for lift to set point
		word btnSevenUp = vexRT[Btn7U]; //for folding claws
		word btnSevenD = vexRT[Btn7D]; //180 degrees

		//Drive Motors
		if(leftJoy > 15 || leftJoy < -15) //dead zones
		{
			if(pinpointDrive)
				setLeftDrivePower(2 * leftJoy / 3);
			else
				setLeftDrivePower(leftJoy);
		}
		else
			setLeftDrivePower(0);
		if(rightJoy > 15 || rightJoy < -15) //dead zones
		{
			if(pinpointDrive)
				setRightDrivePower(2 * rightJoy / 3);
			else
				setRightDrivePower(rightJoy);
		}
		else
			setRightDrivePower(0);

		//Lift Motors


	}
}

task driveMotors()
{
	while(true)
	{
		SensorValue[leftEncoder] = 0;
		SensorValue[rightEncoder] = 0;

		int leftDif = target - SensorValue[leftEncoder];
		int rightDif = target + SensorValue[rightEncoder];
		while(abs(leftDif) >= 10 || abs(rightDif) >= 10)
		{
			//writeDebugStreamLine("running with target %i and power %i", target, motorPower);
			leftDif = target - SensorValue[leftEncoder];
			rightDif = target + SensorValue[rightEncoder];
			int leftPower = leftDif * motorPower * 0.1;
			int rightPower = rightDif * motorPower * 0.1;
			//writeDebugStreamLine("rightPower is %i and leftPower is %i",rightPower, leftPower);
			//writeDebugStreamLine("corrected rightPower is %i and corrected leftPower is %i", 127 * sgn(rightPower), 127 * sgn(leftPower));
			if(abs(leftPower) >= 127)
			{
				writeDebugStreamLine(" if check 1 ");
				setLeftDrivePower(127 * sgn(leftPower));
			}
			else if(abs(leftPower) <= 10)
			{
				writeDebugStreamLine(" else if check 1 ");
				setLeftDrivePower(0);
			}
			else
			{
				writeDebugStreamLine(" else check 1 ");
				setLeftDrivePower(leftPower);
			}
			if(abs(rightPower) >= 127)
			{
				writeDebugStreamLine(" if check 2 ");
				setRightDrivePower(127 * sgn(rightPower));
			}
			else if(abs(rightPower) <= 10)
			{
				writeDebugStreamLine(" else if check 2 ")
				setRightDrivePower(0);
			}
			else
			{
				writeDebugStreamLine(" else check 2 ");
				setLeftDrivePower(rightPower);
			}
		}
		target = 0;
	}
}

task main()
{
	//startTask(driveMotors);
	//driveForDistance(5000);
	startTask(usercontrol);
}
